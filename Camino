class Camino {
private:
    int matriz[5][5];
    Lista<Router*>* routers;
    Paquete* paquete;
    int routOrigen;
    int routFinal;
    Lista<int>* cam = new Lista<int>();
    

public:
    Camino(){};
    Camino(int matrizAdy[5][5], Lista<Router*>* routs);
    ~Camino(void){};

    void setNuevoPaquete(Paquete* paq);
    void copiarMatriz(int matrizAdy[5][5]);
    void actualizarMatriz(void);
    int *dijkstra(int C[][5],int s, int t, int P[]);
    void camino(int P[], int s, int t);
    void guardarCamino(int t);
    void setCamino(void);

};

Camino::Camino(int matrizAdy[5][5], Lista<Router*>* routs)
{
    copiarMatriz(matrizAdy);
    routers = routs;
    for(int i = 0; i<5; i++){
        for(int j = 0; j<5; j++){
            cout<<matriz[i][j]<<" ";
        }
        cout<<"\n";
    }
}

void Camino::copiarMatriz(int matrizAdy[5][5])
{
    for(int i =0; i<5; i++){
        for(int j = 0; j<5; j++){
            matriz[i][j] = matrizAdy[i][j];
        }
    }
    
}

void Camino::setNuevoPaquete(Paquete* paq)
{
    paquete = paq;
    routFinal = paquete->getRouterFinal();

    //Primera vez que se setea el camino
    if(paquete->getCamino()->esVacia()){
        routOrigen = paquete->getRouterOrigen();
    }

    //Ya hay un camino y hay que modificarlo
    else{
        routOrigen = paquete->getSigRouter();
    }
    
    if(routOrigen!=routFinal){
        //actualizarMatriz();
        setCamino();
    }

    else{
        cam->add(routFinal);
    }
}

void Camino::actualizarMatriz(void)
{
    for(int i =0; i<5; i++){
        Router* routAux = buscarRouter(i+1, routers);
        for(int j = 0; j<5; j++){
            if(matriz[i][j]!=INFI){
                int numTurno = routAux->turno(j+1);
                numTurno = 2 + numTurno;
                matriz[i][j] = numTurno;
            }
        }
    }
}

void Camino::setCamino(void)
{
    int *pdist, P[5];
    pdist=dijkstra(matriz,routOrigen - 1,routFinal - 1,P);

    if (pdist[routFinal-1]!=INFI){
        cout<<"El camino para el paquete es: "<<endl;
        cout<<"\n\n distancia minima router " <<routOrigen<<" al router "<<routFinal<<" es= "<<pdist[routFinal-1];
        cout<<"\n\n CAMINO= ";
        camino(P,routOrigen - 1,routFinal - 1);
    }                
    else cout<<"\n NO HAY CAMINO";
    
    cout<<endl<<endl<<endl;
    cam->borrar();
    paquete->setNuevoCamino(cam);
    paquete->getCamino()->impre();
}

int* Camino::dijkstra(int C[][5],int s, int t, int Pre[])
{
    static int D[5]; 
    int S[5];
    int actual, i, k, b;
    int menordist, nuevadist;
    for(i=0;i<5;i++){
                            S[i]=NO_MIEMBRO;
                            D[i]=INFI;
                            Pre[i]= -1;
    }
    S[s]=MIEMBRO; D[s]=0; actual=s; b=1; k=0;
    while((actual!=t)&&(b==1)){
                    b=0;
                    menordist=INFI;
                    for(i=0;i<5;i++){          
                            if(S[i]==NO_MIEMBRO){
                                    nuevadist=D[actual]+C[actual][i];
                                    if(nuevadist<D[i]){
                                            D[i]=nuevadist;
                                            Pre[i]=actual; b=1;
                                    }
                                    if(D[i]<menordist){
                                            menordist=D[i];
                                            k=i;  b=1;
                                    }
                            }
                    }
                    actual=k; 
                    S[actual]=MIEMBRO;
    }
    return D;
}

void Camino::camino(int P[], int s, int t)
{  
    if (t==s){
        int a = s+1;
        cam->addLast(a);
        cout<< a<<"  ";
    }
   else{
        camino(P,s,P[t]);
        int b = t + 1;
        cout<<b<<"  ";
        cam->addLast(b);
   }
}
