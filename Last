#include <cstdlib>
#include <iostream>
#include <sstream>
#include <bitset>
#include <ctime>
#define INFI  9000
#define MIEMBRO   1
#define NO_MIEMBRO 0
const int cantidadRouters = 14;
const int cantidadTerminales = 33;
int matrizAdy[cantidadRouters][cantidadRouters];
int *pdist, i, j, P[cantidadRouters],s,t;

using namespace std;

//-------------------------------------------Lista Template-------------------------------------------------------
template <class T> class Nodo {
private:
    T dato;
    Nodo* next;
public:
    Nodo() { next = NULL; };
    Nodo(T a) { dato = a; next = NULL; };
    void set_dato(T a) { dato = a; };
    void setNext(Nodo* n) { next = n; };
    T getDato() { return dato; };
    Nodo* getNext() { return next; };
    bool es_vacio() { return next == NULL; }
};

template <class T> class Lista {
private: Nodo<T>* czo;
       void addO(T d, Nodo<T>* ant);
       void borrarD(T d, Nodo<T>* ant);
public:
    Lista() { czo = new Nodo<T>(); };
    Lista(Nodo<T>* n) { czo = n; };
    //~Lista(void);
    void add(T d); //sumar nodos a la lista
    bool esVacia(void);
    T cabeza(void); //retorna el dato del primer nodo
    Lista* resto(void); //retorna el puntero al "resto" de la lista
    T suma(T i);
    int size();
    bool esta(T d);// detecta si d esta en la lista
    void borrarDato(T d) { borrarD(d, NULL); }//borra el nodo que contiene d
    void borrar(void); //borra la cabeza
    void borrarLast();//borra el ultimo
    void concat(Lista<T>* l1);// le transfiere los datos de l1 a this
    void tomar(int n);//deja "vivos" los n primeros nodos y borra el resto
    Lista<T>* copy(void);// hace una copia de la lista
    T last(); //retorna el dato del ultimo nodo
};

template <class T> void Lista<T>::add(T d) 
{
    Nodo<T>* nuevo = new Nodo<T>(d);
    nuevo->setNext(czo);
    czo = nuevo;
}

template <class T> bool Lista<T>::esVacia(void)
{
    return czo->es_vacio();
}

template <class T> T Lista<T>::cabeza(void)
{
    if (this->esVacia()) {
        throw std::runtime_error("Error: Lista vacía, no se puede obtener la cabeza");
    }
    return czo->getDato();
}

template <class T> Lista<T>* Lista<T>::resto(void)
{
    Lista* l = new Lista(czo->getNext());
    return (l);
}

template <class T> int Lista<T>::size()
{
    if (this->esVacia()) return 0;
    return 1 + this->resto()->size();
}

template <class T> void Lista<T>::borrar(void)
{ //borra el nodo cabeza
    if (!this->esVacia()) {
        Nodo<T>* tmp = czo;
        czo = czo->getNext();
        delete tmp;
    }
}

template <class T> void Lista<T>::borrarLast()
{ // borra el ultimo nodo
    if (!this->esVacia()) {
        if ((czo->getNext())->getNext() == NULL) {
            delete czo->getNext();
            czo->setNext(NULL);
        }
        else this->resto()->borrarLast();
    }
}

template <class T> void Lista<T>::concat(Lista<T>* l1)
{// le transfiere los datos de l1 a this
    if (!(l1->esVacia())) {
        this->concat(l1->resto());
        this->add(l1->cabeza());
    }
}

template <class T> void Lista<T>::tomar(int n)
{ //deja "vivos" los n primeros nodos y borra el resto
    if (this->size() > n) {
        this->borrarLast();
        this->tomar(n);
    }
}

template <class T> Lista<T>* Lista<T>::copy(void)
{
    Lista<T>* aux = new Lista();
    aux->concat(this);
    return aux;
}

template <class T> bool Lista<T>::esta(T d)
{// busca d en la lista
    if (this->esVacia()) return false;
    if (this->cabeza() == d) return true;
    
    return this->resto()->esta(d);    
}

template <class T> void Lista<T>::borrarD(T d, Nodo<T>* ant)
{
    if (!this->esVacia()) {
        if (d == this->cabeza()) {
            if (ant == NULL) {//al principio
                this->borrar();
            }
            else {//entre medio
                ant->setNext(czo->getNext());
                delete czo;
            }
        }
        else  this->resto()->borrarD(d, czo);

    }
}

template <class T> T Lista<T>::last()
{
    if (!this->esVacia()) {
        if (this->resto()->esVacia())return this->cabeza();
        return this->resto()->last();
    } 
    else{
        return NULL;
    }
}
//------------------------------------------------- Cola Template-------------------------------------------------

template <class T> class Cola :public Lista<T> {
private:
    int numRouter;
    int idAnterior; //Pagina a la que pertenece el ultimo elemento de la cola
    int numOrden; //Cantidad de elementos que tiene la cola
    int anchoBanda;
public:
    Cola(void) { Lista<T>(); };
    Cola(int numRout, int idAnt, int numOrden, int anchoBanda);
    ~Cola(void){};

    //Getters
    int getNumRout(void){return numRouter;};
    int getIdAnt(void){return idAnterior;};
    int getOrdenPagina(void){return numOrden;};
    int getAnchoDeBanda(void){return anchoBanda;};

    //Setters
    void setCantiPaqMas(void){numOrden++;};
    void setCantiPaqMenos(void){numOrden--;};

    T tope(void) { return this->last(); };
    bool colavacia(void) { return this->esVacia(); };
    void encolar(T a) { this->add(a); };
    void desencolar(void) { this->borrarLast(); };
    T ultimo(void) { return this->cabeza(); };
};

template <class T> Cola<T>::Cola(int numRout, int idAnt, int numOrdenCola, int anchoBanda)
{
    numRouter = numRout;
    idAnterior = idAnt;
    numOrden = numOrdenCola;
}

//----------------------------------------Pagina----------------------------------------------------------------

class Pagina {
private:
    int maqOrigen;
    int routOrigen;
    int maqFinal;
    int routFinal;
    int tamanioPagina;
    int numeroPagina;
    bitset<16> IPorigen;
    bitset<16> IPdestino;

public:
    Pagina(void){};
    Pagina(int maquinaOrigen, int routerOrigen, int maquinaFinal, int routFinal, int tamanio, int pagina, bitset<16> IpO, bitset<16> IpD);
    ~Pagina(void){};

    //Getters
    int getNumMaqOrigen(void){return maqOrigen;};
    int getRoutOrigen(){return routOrigen;};
    int getNumMaqFinal(void){return maqFinal;};
    int getRoutFinal(void){return routFinal;}
    int getTamanoPagina(void){return tamanioPagina;};
    int getNumeroPagina(void){return numeroPagina;};
    bitset<16> getIPorigen(void){return IPorigen;};
    bitset<16> getIPdestino(void){return IPdestino;};

    void imprimirPagina();
};

Pagina::Pagina(int maquinaOrigen, int routerOrigen, int maquinaFinal, int routerFinal,  int tamanio, int pagina, bitset<16> IpO, bitset<16> IpD)
{   
    maqOrigen = maquinaOrigen;
    routOrigen = routerOrigen;
    maqFinal = maquinaFinal;
    routFinal = routerFinal;
    tamanioPagina = tamanio;
    numeroPagina = pagina;
    IPorigen = IpO;
    IPdestino = IpD;
}

void Pagina::imprimirPagina()
{
    cout<<"Pagina numero "<<numeroPagina<<endl;
    cout<<"Maquina Origen: "<<maqOrigen<<endl;
    cout<<"Router Origen: "<<routOrigen<<endl;
    cout<<"Maquina Destino: "<<maqFinal<<endl;
    cout<<"Router Destino: "<<routFinal<<endl;
    cout<<"Tamanio de la pagina: "<<tamanioPagina<<endl;
    cout<<"Direccion de Origen: "<<IPorigen<<endl;
    cout<<"Direccion de Destino: "<<IPdestino<<endl;
}

//-----------------------------------------------Paquete--------------------------------------------------

class Paquete {
private:
    int maqOrigen, routOrigen, maqFinal, routFinal, routActual, tamanioPag, numeroPagina, numeroOrdenPagina, numeroOrdenCola;
    Lista<int> camino;
    bitset<16> IPorigen;
    bitset<16> IPdestino;

public:
    Paquete(void){};
    Paquete(int maquinaOrigen, int routerOrigen, int maquinaFinal, int routerFinal, int routerActual, int tamanioPagina, int numPagina, int numOrdenPagina, bitset<16> IPorig, bitset<16> IPdest);
    ~Paquete(void){};

    //Getters
    int getMaquinaOrigen(void){ return maqOrigen;};
    int getRouterOrigen(void){return routOrigen;};
    int getMaquinaFinal(void){return maqFinal;};
    int getRouterFinal(void){return routFinal;};
    int getRoutActual(void){return routActual;};
    int getCantiTotalPaq(void){return tamanioPag;};
    int getNumPag(void){return numeroPagina;};
    int getOrdenPagina(void){return numeroOrdenPagina;};
    int getOrdenCola(void){return numeroOrdenCola;};
    bitset <16> getIPorigen(void){return IPorigen;};
    bitset <16> getIPdestino(void){return IPdestino;};
    Lista<int> getCamino(void){return camino;};
    int getSigRouter(void);

    //Setters
    void setNuevoCamino(Lista<int> nuevoCamino){camino = nuevoCamino;};
    void setRoutActual(int routerAct){routActual = routerAct;};
    void setOrdenCola(int nuevoNum){numeroOrdenCola = nuevoNum;};

    //Borra el primer elemento del camino
    void borrarElemCamino(void){camino.borrar();};

};

Paquete::Paquete(int maquinaOrigen, int routerOrigen, int maquinaFinal, int routerFinal, int routerActual, int tamanioPagina, int numPagina, int numOrdenPagina, bitset<16> IPorig, bitset<16> IPdest)
{
    maqOrigen = maquinaOrigen;
    routOrigen = routerActual;
    maqFinal = maquinaFinal;
    routFinal = routerFinal;
    routActual = routerActual;
    tamanioPag = tamanioPagina;
    numeroPagina = numPagina;
    numeroOrdenPagina = numOrdenPagina;
    numeroOrdenCola = 0;
    IPorigen = IPorig;
    IPdestino = IPdest;
}

//Al llegar un paquete al routerAEnviar, este se elimina de la lista de su camino por lo que el primer elemento del mismo va a ser el siguiente destino
int Paquete::getSigRouter()
{   
    int sigRout = camino.cabeza();
    return sigRout;
}
//---------------------------------------------------------Terminal--------------------------------------------------------------
template <class T> class Terminal  {
private:
    int numTerminal;
    int numRouter;
    T routerAsociado;
    bitset <16> direcMaquina;
    Pagina* paginaEnviar;
    Lista<Pagina*>* paginasRecibidas;
    int numMaqGnral;

public:
    Terminal(void){};
    Terminal(int numeroMaquina, int numeroROuter, T router, int numMaqGeneral);

    //Getters
    int getNumeroTerminal(void){return numTerminal;};
    int getNumeroRouter(void){return numRouter;};
    T getRouterAsociado(void){return routerAsociado;};
    bitset<16> getDirecMaquina(void){return direcMaquina;};
    int getNumMaqGeneral(void){return numMaqGnral;}

    bitset<16> setDireccion(int maq,  int rout);

    Pagina* generarPaginaAleatoria(Lista<T>* rout,int cantidadRout, int numPag, int numTerminalFinal, int numRoutFinal);
    int generarTamanioAleatorio(void);
    void enviarPagina(Lista<T>* rout,int cantidadRout, int numPag, int numMaqFinal, int numRoutFinal);
    void recibirPagina(Pagina* pag);
    void imprimirRecepcion(Pagina* pag);
};

template <class T> Terminal<T>::Terminal(int numeroMaquina, int numeroRouter, T router, int numMaqGeneral)
{
    numTerminal = numeroMaquina;
    numRouter = numeroRouter;
    routerAsociado = router;
    direcMaquina = setDireccion(numeroMaquina, numeroRouter);
    paginasRecibidas = new Lista<Pagina*>;
    numMaqGnral = numMaqGeneral;
}

template<class T> bitset<16> Terminal<T>::setDireccion(int maq, int rout)
{
    bitset<16> a (maq);
    bitset<16> b (rout);
    (a<<=8);
    direcMaquina = (a|b);
    return direcMaquina;
}

//Generar Pagina a enviar

template <class T> Pagina* Terminal<T>::generarPaginaAleatoria(Lista<T>* rout,int cantidadRout, int numPag, int numeroTerminalFinal, int numeroRoutFinal)
{   
    int tamanioPag = generarTamanioAleatorio();
    int numTerminalFinal = numeroTerminalFinal;
    int numRoutFinal = numeroRoutFinal;
    int routOrigen = numRouter;
    bitset<16> IPdest = setDireccion(numTerminalFinal, numRoutFinal);
    Pagina* nueva = new Pagina(numTerminal, routOrigen, numTerminalFinal,numRoutFinal, tamanioPag, numPag, direcMaquina, IPdest);
    return nueva;
}

template<class T> int Terminal<T>::generarTamanioAleatorio(void)
{
    //Eleccion de 60 como tamanio maximo aleatorio
    srand(time(nullptr));
    int tamanio = rand()% 60;
    return tamanio;
}

//Crear la pagina y luego enviarla al router asociado
template<class T> void Terminal<T>::enviarPagina(Lista<T>* rout,int cantidadRout, int numPag, int numMaqFinal, int numRoutFinal)
{
    paginaEnviar = generarPaginaAleatoria(rout, cantidadRout, numPag, numMaqFinal, numRoutFinal);
    routerAsociado->recibirPagina(paginaEnviar);
}

//Recibir pagina enviada
template<class T> void Terminal<T>::recibirPagina(Pagina* pag)
{
    paginasRecibidas->add(pag);
    imprimirRecepcion(pag);
}

template<class T> void Terminal<T>::imprimirRecepcion(Pagina* pag)
{
    cout<<"La maquina "<<numTerminal<<" recibio exitosamente la pagina numero: "<<pag->getNumeroPagina()<<endl;
    cout<<"Direccion de envio: "<<pag->getIPorigen()<<endl;
    cout<<"Direccion de destino: "<<pag->getIPdestino()<<endl;
}

//----------------------------------------------------------Router-------------------------------------------------------
class Router{
private:
    int ID;
    int anchoBanda;
    int cantidadVecinos;
    int cantidadTerminales;
    Lista<Router*>* vecinos;
    Lista<Terminal<Router*>*>* terminales;
    Lista<Cola<Paquete*>*>* colasTrafico;
    Lista<Cola<Paquete*>*>* colasEspera;
    Lista<Lista<Lista<Paquete*>*>*>* listasTerminales;
    Lista<int>* veciConEspera;
    Lista<int>* veciConColaTrafico;
    Lista<int>* numVecinos;
    Lista<Paquete*>* listaVacia;
    Lista<Paquete*>* listaAEnviar;
    Lista<Paquete*>* listaConCaminos;

public:
    Router(void){};
    Router(int id);
    ~Router(void){};

    //Gettters
    int getID(void){return ID;};
    int getAnchoBanda(void){return anchoBanda;};
    int getCantidadVecinos(void){return cantidadVecinos;};
    int getCantidadTerminales(void){return cantidadTerminales;};
    Lista<Router*>* getVecinos(void){return vecinos;};
    Lista<Terminal<Router*>*>* getTerminales(void){return terminales;};
    Lista<Cola<Paquete*>*>* getColasEspera(void){return colasEspera;};
    Lista<Cola<Paquete*>*>* getColasTrafico(void){return colasTrafico;};
    Lista<Lista<Lista<Paquete*>*>*>* getListasTerminales(void){return listasTerminales;};
    Lista<int>* getNumVecinos(void){return numVecinos;};
    Lista<Paquete*>* getListaAEnviar(void){return listaAEnviar;};

    //Setters
    void setNuevoVecino(Router* vecino);
    void setNuevaTerminal(Terminal<Router*>* terminal);
    void setListaConCaminos(Lista<Paquete*>* listaCaminos){ listaConCaminos = listaCaminos;};

    //Busqueda
    static Router* buscarRouter(int ID,Lista<Router*>* vecinos);
    static Terminal<Router*>* buscarTerminal(int ID, Lista<Terminal<Router*>*>* terminales);
    Lista<Paquete*>* buscarLista(int ID, Lista<Lista<Lista<Paquete*>*>*>* listasTerminales, int numeroPag);
    Cola<Paquete*>* buscarCola(int ID, Lista<Cola<Paquete*>*>* colas);

    //Recibir Pagina y crear Paquetes
    void recibirPagina(Pagina* pagina);
    void armadoDePaquetes(Pagina* pagina);
    void enviarDirecto(Paquete* paquete);
    void addOrdenado(Paquete* paquete, Lista<Paquete*>* listaTerminal);
    Lista<Paquete*>* armadoLista(Lista<Paquete*>* listaTerminal, int numIndice, Paquete* paquete);

    //Reconstruccion y envio de pagina
    void recibirPaqueteFinal(Paquete* paquete);
    void reconstruirPagina(Lista<Paquete*>* paquetes);
    void recibirListaConCaminos(Lista<Paquete*>*);
    void enviarPagina(Pagina* pagina);

    //Recepcion de Paquetes y reenvio
    void recibirPaquete(Paquete* paquete); 
    void recibirPaqueteVecino(Paquete* paquete); //Uso gestion de vecinos
    void ciclo();
    bool pertenece(int numPag, int router);
    void enviarPaqueteVecino(Paquete* paquete);
    bool veciTieneEspera(int ID);
    bool veciTieneTrafico(int ID);

    void vaciarLista();
    void imprimirRecepcion(Paquete* paquete, bool final);
    int turno(int ID);
};

Router::Router(int id)
{
    ID = id;
    cantidadVecinos = 0;
    cantidadTerminales = 0;
    vecinos = new Lista<Router*>();
    terminales = new Lista<Terminal<Router*>*>();
    colasTrafico = new Lista<Cola<Paquete*>*>();
    colasEspera = new Lista<Cola<Paquete*>*>();
    listasTerminales = new Lista<Lista<Lista<Paquete*>*>*>();
    numVecinos = new Lista<int>();
    listaVacia = new Lista<Paquete*>();
    listaAEnviar = new Lista<Paquete*>();
    listaConCaminos = new Lista<Paquete*>();
}

void Router::setNuevoVecino(Router* vecino)
{
    vecinos->add(vecino);
    numVecinos->add(vecino->getID());
    cantidadVecinos++;
}

void Router::setNuevaTerminal(Terminal<Router*>* terminal)
{
    terminales->add(terminal);
    cantidadTerminales++;
}

Router* Router::buscarRouter(int ID, Lista<Router*>* vecinos)
{   
    if(vecinos->esVacia()) return nullptr;
    if(vecinos->cabeza()->getID() == ID){
        return vecinos->cabeza();
    }
    if(vecinos->esVacia()) return nullptr;
    else return buscarRouter(ID, vecinos->resto());
}

Terminal<Router*>* Router::buscarTerminal(int ID, Lista<Terminal<Router*>*>* terminales)
{
    if(terminales->esVacia()) return nullptr;
    if(terminales->cabeza()->getNumeroTerminal() == ID){
        return terminales->cabeza();
    }
    else return buscarTerminal(ID, terminales->resto());
}

Lista<Paquete*>* Router::buscarLista(int ID, Lista<Lista<Lista<Paquete*>*>*>* listasTerminales, int numeroPagina)
{
    if(listasTerminales->esVacia()) return nullptr;
    Lista<Lista<Paquete*>*>* listaTerminalesAux = listasTerminales->cabeza(); 

    if(listaTerminalesAux->cabeza()->cabeza()->getMaquinaFinal() == ID){
        int cantidadPaginas = listaTerminalesAux->size();
        for(int i=0; i<cantidadPaginas; i++){
            Lista<Paquete*>* listaBuscada = listaTerminalesAux->cabeza();
            if(listaBuscada->cabeza()->getNumPag()==numeroPagina){
                return listaBuscada;
            }
            else listaTerminalesAux = listaTerminalesAux->resto(); //Pasa a la siguiente pagina
        }
    }
    else return buscarLista(ID, listasTerminales->resto(), numeroPagina); //Pasa a la siguiente maquina
    return nullptr;
}

Cola<Paquete*>* Router::buscarCola(int ID, Lista<Cola<Paquete*>*>* colas)
{
    if(colas->esVacia()) return nullptr;
    Cola<Paquete*>* colaBuscada = colas->cabeza();
    if(colaBuscada->getNumRout() == ID) return colaBuscada;
    else return buscarCola(ID, colas->resto());
}

void Router::recibirPagina(Pagina* pagina)
{
    armadoDePaquetes(pagina);
}

void Router::armadoDePaquetes(Pagina* pagina)
{
    int cantidadPaquetes = pagina->getTamanoPagina();
    for(int i= 0; i<cantidadPaquetes; i++){
        Paquete* paquete = new Paquete(pagina->getNumMaqOrigen(),pagina->getRoutOrigen(), pagina->getNumMaqFinal(), pagina->getRoutFinal(), ID, pagina->getTamanoPagina(), pagina->getNumeroPagina(), i+1, pagina->getIPorigen(),pagina->getIPdestino());
        listaAEnviar->add(paquete);
    }
}
void Router::recibirListaConCaminos(Lista<Paquete*>* listaCaminos)
{
    setListaConCaminos(listaCaminos);
    for(int i = 0; i<listaCaminos->size(); i++){
        Paquete* paquete = listaConCaminos->cabeza();
        enviarDirecto(paquete);
        listaConCaminos->borrar();
    }
    vaciarLista();
}
void Router::enviarDirecto(Paquete* paquete)
{
    int sigRouter = paquete->getSigRouter();
    buscarRouter(sigRouter, vecinos)->recibirPaquete(paquete);
}

void Router::reconstruirPagina(Lista<Paquete*>* paquetes)
{
    Paquete* paqAux = paquetes->cabeza();
    Pagina* pagina = new Pagina(paqAux->getMaquinaOrigen(), paqAux->getRouterOrigen(), paqAux->getMaquinaFinal(),paqAux->getRouterFinal(),paqAux->getCantiTotalPaq(),paqAux->getNumPag(),paqAux->getIPorigen(), paqAux->getIPdestino());
    enviarPagina(pagina);
}

void Router::enviarPagina(Pagina* pagina)
{
    int maqDestino = pagina->getNumMaqFinal();
    buscarTerminal(maqDestino, terminales)->recibirPagina(pagina);
}

void Router::recibirPaquete(Paquete* paquete)
{
    paquete->borrarElemCamino();
    if(paquete->getRouterFinal()==ID){
        recibirPaqueteFinal(paquete);
    }
    else recibirPaqueteVecino(paquete);
}

void Router::recibirPaqueteFinal(Paquete* paquete)
{
    int maqTerminal = paquete->getMaquinaFinal();
    int cantiTotalPaquetes = paquete->getCantiTotalPaq();
    int numPagina = paquete->getNumPag();
    Lista<Paquete*>* listaMaquina = buscarLista(maqTerminal, listasTerminales,numPagina);
    addOrdenado(paquete, listaMaquina);
    if(listaMaquina->size()==cantiTotalPaquetes)reconstruirPagina(listaMaquina);
    imprimirRecepcion(paquete, true);
}

void Router::addOrdenado(Paquete* paquete, Lista<Paquete*>* listaTerminal)
{   
    if (listaTerminal->esVacia()) {//el primero
        listaTerminal->add(paquete);
    }

    if(paquete->getOrdenPagina()>listaTerminal->last()->getOrdenPagina()){//el ultimo
        Lista<Paquete*>* paqueteAlFinal = new Lista<Paquete*>();
        paqueteAlFinal->add(paquete);
        listaTerminal->concat(paqueteAlFinal);
    }

    else{
        Lista<Paquete*>* listaAux = listaTerminal;
        for(int i = 0; i<listaAux->size() ; i++){
            if(listaAux->cabeza()->getOrdenPagina()>paquete->getOrdenPagina()){//entre Medio
                armadoLista(listaTerminal, i, paquete);
            }
            else listaAux = listaAux->resto();
        }
    }
}

Lista<Paquete*>* Router::armadoLista(Lista<Paquete*>* listaTerminal, int numIndice, Paquete* paquete)
{
    Lista<Paquete*>* listaAux1 = listaTerminal;
    listaAux1->tomar(numIndice);
    Lista<Paquete*>* listaAux2 = listaTerminal;
    for(int j = 0; j<numIndice; j++){
        listaAux2->borrar();
    }
    listaAux2->add(paquete);
    listaAux1->concat(listaAux2);
    return listaAux1;
}

void Router::recibirPaqueteVecino(Paquete* paquete)
{
    int siguienteRout = paquete->getSigRouter();
    if(veciTieneEspera(siguienteRout)){//Si existe una cola de espera para el trafico del router
        if(pertenece(paquete->getNumPag(), siguienteRout)){//Si pertenece a esa cola de espera
            Cola<Paquete*>* colaEsp= buscarCola(siguienteRout, colasEspera);//Se añade
            colaEsp->encolar(paquete);
            colaEsp->setCantiPaqMas();
        }
        else{
            Cola<Paquete*>* colaTraf = buscarCola(siguienteRout, colasTrafico);
            colaTraf->encolar(paquete);
            colaTraf->setCantiPaqMas();
            Paquete* paq = buscarCola(siguienteRout, colasEspera)->tope(); 
            colaTraf->encolar(paq); //Se encola tambien un paquete de la cola de espera
            colaTraf->setCantiPaqMas();
            Cola<Paquete*>* colaEspe = buscarCola(siguienteRout, colasEspera); //Se desencola de la lista de espera
            colaEspe->desencolar();
            colaEspe->setCantiPaqMenos();
            if(colaEspe->esVacia()){
                int numRouter = colaEspe->getNumRout();
                colasEspera->borrarDato(colaEspe);
                veciConEspera->borrarDato(numRouter);
            }
        }
    }

    else{
        if(veciTieneTrafico(siguienteRout)){
            int ant = buscarCola(siguienteRout, colasTrafico)->getIdAnt();

            if(paquete->getNumPag()==ant){
                int anchoBanda = buscarRouter(siguienteRout, vecinos)->getAnchoBanda();
                Cola<Paquete*>* colaEspera = new Cola<Paquete*>(siguienteRout,paquete->getNumPag(),1,anchoBanda);
                colaEspera->encolar(paquete);
                colaEspera->setCantiPaqMas();
                colasEspera->add(colaEspera);
                veciConEspera->add(siguienteRout);
            }
            else{
                Cola<Paquete*>* colaTraf = buscarCola(siguienteRout, colasTrafico);
                colaTraf->encolar(paquete);
                colaTraf->setCantiPaqMas();
            }
        }
        else{
            int anchoDeBanda = buscarRouter(siguienteRout,vecinos)->getAnchoBanda();
            Cola<Paquete*>* colaTrafico = new Cola<Paquete*>(siguienteRout,paquete->getNumPag(),1, anchoDeBanda);
            colaTrafico->encolar(paquete);
            colaTrafico->setCantiPaqMas();
            colasTrafico->add(colaTrafico);
            veciConColaTrafico->add(siguienteRout);
        }
    }
    imprimirRecepcion(paquete, false);
}

void Router::ciclo()
{   
    Cola<Paquete*>* colaAux;
    Lista<Cola<Paquete*>*>* listaColasAux = colasTrafico;

    //Recorre la Lista
    for(int i = 0; i< colasTrafico->size(); i++){
        colaAux = listaColasAux->cabeza();

        //Recorre la cola
        for(int j = 0; j<colaAux->getAnchoDeBanda(); j++){
            Paquete* paquete= colaAux->tope();
            enviarPaqueteVecino(paquete);
            colaAux->desencolar();
            colaAux->setCantiPaqMenos();

            //Caso en que quede vacia la cola de Espera
            if(colaAux->esVacia()){
                int numRout = colaAux->getNumRout();
                colasTrafico->borrarDato(colaAux);
                veciConColaTrafico->borrarDato(numRout);
                break;
            }
        }
        listaColasAux = listaColasAux->resto();
    }
}

bool Router::pertenece(int numPag, int router)
{
    int ant = buscarCola(router, colasEspera)->getIdAnt();
    if(ant == numPag) return true;
    else return false;
}

bool Router::veciTieneEspera(int ID)
{
    if(veciConEspera->esta(ID)){
        return true;
    }
    else return false;
}

bool Router::veciTieneTrafico(int ID)
{
    if(veciConColaTrafico->esta(ID)){
        return true;
    }
    else return false;
}

void Router::enviarPaqueteVecino(Paquete* paquete)
{
    int routDestino = paquete->getSigRouter();
    buscarRouter(routDestino, vecinos)->recibirPaquete(paquete);
}

void Router::vaciarLista()
{
    listaAEnviar = listaVacia;
}

void Router::imprimirRecepcion(Paquete* paquete, bool final){
    cout<<"Se recibio paquete de pagina numero: "<<paquete->getNumPag()<<endl;
    if(final)cout<<"Final: si"<<endl;
    else cout<<"Final: no"<<endl;
    cout<<"Router receptor: "<<ID;
    cout<<"Emitido por maquina con direccion: "<<paquete->getIPorigen()<<endl;
    cout<<"Con destino maquina con direccion: "<<paquete->getIPdestino()<<endl;
}

int Router::turno(int ID)
{
    Cola<Paquete*>* colaVecino = buscarCola(ID, colasTrafico);
    if(colaVecino == nullptr)return 0;
    else{
        int anchoBanda = colaVecino->getAnchoDeBanda();
        int numOrden = colaVecino->getOrdenPagina();
        int ciclosEspera = 0;
        numOrden = numOrden - anchoBanda;
        
        while(numOrden>anchoBanda){
            ciclosEspera++;
            numOrden = numOrden - anchoBanda;
        }
        return ciclosEspera;
    }
}
//----------------------------------------------------------Extra------------------------------------------------------------
Router* buscarRouter(int numRout, Lista<Router*>* routers) 
{
    if(routers->esVacia()) return nullptr; 
    if(routers->cabeza()->getID() == numRout){
        return routers->cabeza();
    }
    else return buscarRouter(numRout, routers->resto());
}

Terminal<Router*>* buscarTerminal(int ID, Lista<Terminal<Router*>*>* terminales)
{
    if (terminales == nullptr || terminales->esVacia()) {
        throw std::runtime_error("Error: Lista vacía, no se puede obtener la cabeza");
    }

    if (terminales->cabeza()->getNumeroTerminal() == ID) {
        return terminales->cabeza();
    } else {
        return buscarTerminal(ID, terminales->resto());
    }
}

//---------------------------------------------------------Camino-----------------------------------------------------------
class Camino{
private:
    bool ultimoRouter;
    Paquete* paq;
    Router* basePartida;
    Router* proximo;
    int sigRouter;
    Lista<Router*>* routers;
    Lista<int> caminoAux;
    int matriz[cantidadRouters][cantidadRouters];
    Lista<int> camino;

public:
    Camino(void){};
    Camino(int matrizAdy[cantidadRouters][cantidadRouters], Paquete* paquete,Router* routBase, Lista<Router*>* rout);
    ~Camino(void){};
    
    int getTurno(Router* routerProx);

    void setProximo(int ID);
    void setCamino(Paquete* paquete);

    void copiarMatriz(int matrizAdy[cantidadRouters][cantidadRouters]);
};

Camino::Camino(int matrizAdy[cantidadRouters][cantidadRouters], Paquete* paquete,Router* routBase, Lista<Router*>* rout)
{
    copiarMatriz(matrizAdy);
    paq = paquete;
    basePartida = routBase;
    routers = rout;
    caminoAux = paquete->getCamino();
    proximo = basePartida;
    if(caminoAux.size()>1){
        sigRouter = caminoAux.cabeza();
        setCamino(paquete);
    }
    else  sigRouter = NULL;
}

int Camino::getTurno(Router* prox)
{   
    if(sigRouter!=NULL){
        int numTurno = prox->turno(sigRouter);
        return numTurno;
    }
    return NULL;
}

void Camino::setProximo(int ID){
    proximo = buscarRouter(ID, routers);
    sigRouter = caminoAux.cabeza();
}

void Camino::setCamino(Paquete* paquete)
{

}
void Camino::copiarMatriz(int matrizAdy[cantidadRouters][cantidadRouters])
{
    for(int i =0; i<cantidadRouters; i++){
        for(int j = 0; j<cantidadRouters; j++){
            matriz[i][j] = matrizAdy[i][j];
        }
    }
}

//----------------------------------------------------------Administrador-------------------------------------------------------
class Administrador{
private:
    Lista<Paquete*>* listaPaquetes;
    Lista<Paquete*>* listaAux;
    Lista<Router*>* routers;
    int matriz[cantidadRouters][cantidadRouters];
    
public: 
    Administrador(void){};
    Administrador(Lista<Paquete*>* paquetes, Lista<Router*>* routs,int matrizAdy[cantidadRouters][cantidadRouters]);
    ~Administrador(void){};
    
    void copiarMatriz(int matrizAdy[cantidadRouters][cantidadRouters]);
    void resetearCaminos();
};

Administrador::Administrador(Lista<Paquete*>* paquetes, Lista<Router*>* routs,int matrizAdy[cantidadRouters][cantidadRouters])
{
    copiarMatriz(matrizAdy);
    listaPaquetes = paquetes;
    routers = routs;
}

void Administrador::resetearCaminos()
{   
    listaAux = listaPaquetes;
    
    for(int i=0; listaPaquetes->size(); i++){
        Paquete* paquete = listaAux->cabeza();
        int sigRout = paquete->getSigRouter();
        Router* routBase = buscarRouter(sigRout, routers);
        Camino* camino = new Camino(matriz,paquete, routBase, routers);
        listaAux->borrar();
    }
}

void Administrador::copiarMatriz(int matrizAdy[cantidadRouters][cantidadRouters])
{
    for(int i =0; i<cantidadRouters; i++){
        for(int j = 0; j<cantidadRouters; j++){
            matriz[i][j] = matrizAdy[i][j];
        }
    }
}
//----------------------------------------------------------Main-------------------------------------------------------------
int main(){
    Lista<Router*>* rout = new Lista<Router*>(); //Lista de todos los routers creados
    Lista<Terminal<Router*>*>* terminales = new Lista<Terminal<Router*>*>(); //Lista de todas las maquinas creadas, independiente del routerAEnviar asociado
    Lista<Paquete*>* paquetes = new Lista<Paquete*>(); //Lista de todos los paquetes creados, independiente de la maquina creadora
    int pagsCanti = rand() % 50; //Numero aleatorio de paginas generadas
    int baseCantidadVeci = 1; //Minimo de cantidad de vecinos por router
    int limInferior = 0;
    fill(*matrizAdy, *matrizAdy + cantidadRouters*cantidadRouters, INFI); //Inicializo la matriz de adyacencia con todos los nodos desconectados
    Lista<Paquete*>* listaVacia = new Lista<Paquete*>();
    Lista<Paquete*>* listaAEnviar = new Lista<Paquete*>();
    Lista<Paquete*>* listaRecibida = new Lista<Paquete*>();
    
    //Creacion de los routers
    for(int i = 0; i <= cantidadRouters; i++){
        Router* nuevoRout = new Router(i+1);
        rout->add(nuevoRout);
    }

    //Creacion de Terminales
    for(int i = 0; i < cantidadTerminales; i++){
        int numMaq,numRout;
        int idCantTermi;
        bool apto = false;//Comprobacion que numero de maquinas del routerAEnviar elegido sea menor que el limite (256)

        //Bucle para seleccionar un routerAEnviar aleatorio apto, con cantidad de maquinas disponibles 
        while(!apto){ 
            srand(time(nullptr));
            numRout = rand() % (cantidadRouters - 1); //Eleccion de Router Aleatorio
            Router* routTentativo = buscarRouter(numRout, rout); 
            idCantTermi = routTentativo->getCantidadTerminales();//Obtencion de la cantidad de Maquinas asociada al routerAEnviar aleatorio obtenido
            
            if(idCantTermi <256 ){  //Comprobacion de la cantidad de maquinas es menor a la maxima Tentativo
                numMaq = idCantTermi++;
                Terminal<Router*>* nuevaTerminal = new Terminal<Router*>(numMaq,numRout,routTentativo,i);//Creacion de la nueva maquina
                routTentativo->setNuevaTerminal(nuevaTerminal);//Asociacion de la maquina al routerAEnviar
                terminales->add(nuevaTerminal);//Agregado de la maquina nueva a la lista de maquinas  
                apto = true;  
            }            
        }
    }
    
    // Creacion de conexiones entre los Routers
    // Dos bucles: el primero para elegir los routers vecinos y guardarlos, y el segundo para guardar en los vecinos ese routerAEnviar
    Lista<Router*>* routAux = rout;

    for(int i = 0; i < cantidadRouters; i++){ //i representa el numero del routerAEnviar al que se le esta designando los vecinos
        Router* routActual = routAux->cabeza();
        Router* routVecino;
        int idActual = routActual->getID();
        int idVecino;
        int cantVeciAleat = (rand() % baseCantidadVeci) + limInferior;

        for(int j = 0; j<cantVeciAleat; j++){
            srand(time(nullptr));
            int numRoutVeci = rand() % (cantidadRouters);
            if(numRoutVeci!=routActual->getID()){
                routVecino = buscarRouter(numRoutVeci, rout);
                idVecino = routVecino->getID();

                routActual->setNuevoVecino(routVecino);
                routVecino->setNuevoVecino(routActual);
                matrizAdy[idActual][idVecino] = 1; //Actualizacion de la matriz de Adyacencia
            }
            else j--; //Caso en que el numero del routerAEnviar proutVecino sea su mismo numero de ID
        }
        limInferior++;
        routAux = routAux->resto(); //Movimiento hacia el siguiente routerAEnviar
    }

    //Creacion de paginas 

    for(int i=0; i<pagsCanti; i++){

        //Seleccion de maquina generadora aleatoria
        srand(time(nullptr));
        int numTerminalAleat = rand() % cantidadTerminales;
        Terminal<Router*>* terminalOrigenAleat = buscarTerminal(numTerminalAleat, terminales);
        srand(66);
        int numTerminalFinal = rand() % cantidadTerminales;
        if(numTerminalAleat == numTerminalFinal){
            srand(11117);
            numTerminalFinal = rand() % cantidadTerminales;
        }

        Terminal<Router*>* terminalFinalAleat = buscarTerminal(numTerminalFinal, terminales);
        //Generacion de la pagina y envio
        terminalOrigenAleat->enviarPagina(rout, cantidadRouters, i, terminalFinalAleat->getNumeroTerminal(), terminalFinalAleat->getNumeroRouter());
        
        Router* router = terminalOrigenAleat->getRouterAsociado();
        listaRecibida = router->getListaAEnviar();
        for(int j = 0; j<listaRecibida->size(); j++){
            Paquete* paquete = listaRecibida->cabeza();
            int sigRouter = paquete->getSigRouter();
            Router* routBase = buscarRouter(sigRouter, rout);
            Camino* camino = new Camino(matrizAdy, paquete,routBase,rout);
            listaAEnviar->add(paquete);
            listaRecibida->borrar();
        }
        router->recibirListaConCaminos(listaRecibida);
        router->vaciarLista();
        listaAEnviar = listaVacia;
    }
    
    //Se inician los ciclos 
    Administrador* administrador= new Administrador(paquetes, rout,matrizAdy);
    int ciclos = 10;
    int dosCiclos = 0;
    Lista<Router*>* routsAux = new Lista<Router*>();
    for(int i = 0; i<ciclos; i++){
        routsAux = rout;
        if(dosCiclos>2){
            administrador->resetearCaminos();
            dosCiclos = 0;
        }
        
        for(int j = 0; j<rout->size(); j++){
            Router* auxRout = routsAux->cabeza();
            cout<<"Inicio de ciclo"<<endl;
            auxRout->ciclo();
            routsAux->borrar();
        }
        
        dosCiclos++;
    }

    cout<<"Hello World";
     
    return EXIT_SUCCESS;
}
